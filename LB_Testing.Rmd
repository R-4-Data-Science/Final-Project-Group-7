---
title: "LB_Testing"
output: html_document
---
```{r}
adult <- read.csv("~/Desktop/Statistics/adult.csv", 
         sep = ";", 
         header = FALSE,
         strip.white = TRUE
)

colnames(adult) <- c(
  "index", "age", "workclass", "fnlwgt", "education", "education.num",
  "marital.status", "occupation", "relationship", "race", "sex",
  "capital.gain", "capital.loss", "hours.per.week", "native.country", "income"
)

adult <- adult[ , -1]   # remove row index column

# convert categorical columns to factor
adult$workclass       <- as.factor(adult$workclass)
adult$education       <- as.factor(adult$education)
adult$marital.status  <- as.factor(adult$marital.status)
adult$occupation      <- as.factor(adult$occupation)
adult$relationship    <- as.factor(adult$relationship)
adult$race            <- as.factor(adult$race)
adult$sex             <- as.factor(adult$sex)
adult$native.country  <- as.factor(adult$native.country)
adult$income          <- as.factor(adult$income)
```

```{r}
multi_path_forward <- function(data, response,
                               K = 5, epsilon = 1e-6, delta = 2, L = 25,
                               model_type = NULL) {

  # ---- Local helper: detect model type -------------------------------------
  detect_model_type <- function(y) {
    if (is.factor(y) && nlevels(y) == 2) return("logistic")
    if (is.logical(y)) return("logistic")
    if (is.numeric(y)) {
      uy <- unique(stats::na.omit(y))
      if (length(uy) <= 2 && all(uy %in% c(0, 1))) return("logistic")
    }
    "linear"
  }

  # ---- Auto-detect model type ----------------------------------------------
  if (is.null(model_type)) {
    model_type <- detect_model_type(data[[response]])
    cat("Detected model type:", model_type, "\n")
  } else {
    model_type <- match.arg(tolower(model_type), c("linear", "logistic"))
  }

  predictors <- setdiff(names(data), response)

  # ---- Model fitting helper ------------------------------------------------
  fit_model <- function(vars) {
    formula_str <- paste(
      response, "~",
      ifelse(length(vars) == 0, "1", paste(vars, collapse = "+"))
    )
    f <- stats::as.formula(formula_str)

    if (model_type == "linear") {
      stats::lm(f, data = data)
    } else {
      stats::glm(f, data = data, family = stats::binomial())
    }
  }

  # ---- Initialize with intercept-only model --------------------------------
  start_fit <- fit_model(character())
  start_aic <- stats::AIC(start_fit)

  models <- list(
    list(
      variables = character(),
      AIC = start_aic,
      fit = start_fit
    )
  )

  frontiers <- list()
  aic_by_model <- list()

  step <- 1L

  repeat {
    new_models <- list()
    model_hash <- character()

    for (m in models) {
      current_vars <- m$variables
      remaining_vars <- setdiff(predictors, current_vars)
      if (length(remaining_vars) == 0L) next

      candidate_models <- list()

      for (v in remaining_vars) {
        new_vars <- c(current_vars, v)
        key <- paste(sort(new_vars), collapse = ",")

        if (key %in% model_hash) next

        fit <- try(
          suppressWarnings(fit_model(new_vars)),
          silent = TRUE
        )
        if (inherits(fit, "try-error")) next

        aic_val <- stats::AIC(fit)
        if (!is.finite(aic_val)) next

        candidate_models[[key]] <- list(
          variables = new_vars,
          AIC = aic_val,
          fit = fit
        )
        model_hash <- c(model_hash, key)
      }

      if (length(candidate_models) == 0L) next

      aic_vals <- vapply(candidate_models, `[[`, numeric(1), "AIC")
      best_aic <- min(aic_vals)

      # ---- Keep near-optimal children ---------------------------------------
      selected <- candidate_models[aic_vals <= best_aic + delta]

      # ---- Progress only if parent improves ---------------------------------
      if (best_aic < m$AIC - epsilon) {
        new_models <- c(new_models, selected)
      }
    }

    if (length(new_models) == 0L || step >= K) break

    # ---- Sort & truncate ----------------------------------------------------
    aics <- vapply(new_models, `[[`, numeric(1), "AIC")
    ord <- order(aics)
    new_models <- new_models[ord]
    new_models <- new_models[seq_len(min(L, length(new_models)))]

    frontiers[[step]] <- new_models

    # ---- Save AIC dictionary ------------------------------------------------
    for (m in new_models) {
      key <- paste(sort(m$variables), collapse = ",")
      aic_by_model[[key]] <- m$AIC
    }

    models <- new_models
    step <- step + 1L
  }

  list(
    path_forest = frontiers,
    aic_by_model = aic_by_model,
    meta = list(
      K = K,
      epsilon = epsilon,
      delta = delta,
      L = L,
      model_type = model_type
    )
  )
}
```

#Debug by chunk 
```{r}
multi_path_forward <- function(data, response,
                               K = 5, epsilon = 1e-6, delta = 2, L = 25,
                               model_type = NULL) {

  # ---- Local helper: detect model type -------------------------------------
  detect_model_type <- function(y) {
    if (is.factor(y) && nlevels(y) == 2) return("logistic")
    if (is.logical(y)) return("logistic")
    if (is.numeric(y)) {
      uy <- unique(stats::na.omit(y))
      if (length(uy) <= 2 && all(uy %in% c(0, 1))) return("logistic")
    }
    "linear"
  }
  if (is.null(model_type)) {
    model_type <- detect_model_type(data[[response]])
    cat("Detected model type:", model_type, "\n")
  } else {
    model_type <- match.arg(tolower(model_type), c("linear", "logistic"))
  }

  predictors <- setdiff(names(data), response)
}
```


```{r}
result <- multi_path_forward(
  data = adult,
  response = "income",
  K = 5,        # number of levels
  epsilon = 1e-6,
  delta = 2,    # near-optimal threshold
  L = 25        # top models to keep at each step
)

```

```{r}
stability <- function(data, response, B = 100, K = 5, epsilon = 1e-6, 
                           delta = 2, L = 25, model_type = NULL) {
  
result_matrix <- matrix(0, nrow = B, ncol = length(setdiff(names(data), response)),
  dimnames = list(NULL, setdiff(names(data), response)))
  
  resampling <- vector("list", B)
  predictors <- colnames(result_matrix)
  p_length <- length(predictors)
  
  for (b in 1:B) {
    # Bootstrap
    index_b <- sample(1:nrow(data), size = nrow(data), replace = TRUE)
    data_b <- data[index_b, , drop = FALSE]
    
    # Fit model
    models_b <- build_paths(data_b, response,
                            K = K, epsilon = epsilon,
                            delta = delta, L = L,
                            model_type = model_type)
    
    # Feature inclusion
    counts <- rep(0, p)
    names(counts) <- predictors
    if (length(models_b) > 0) {
      for (m in models_b) counts[m$variables] <- counts[m$variables] + 1
    }
    
    # Proportions for Bootstrap sample
    z_j_b <- counts / (ifelse(length(models_b) > 0, length(models_b), 1)) # calculates ( z_j^{(b)} )
    result_matrix[b, ] <- z_j_b
    
    # Store proportions
    resampling [[b]] <- z_j_b
  }
  
  # Calculate stability
  pi <- colMeans(result_matrix)
  path_stability <- data.frame(variable = predictors, pi = pi)
  path_stability <- path_stability[order(-path_stability$pi), ]
  
  return(list(path_stability = path_stability, resampling = resampling))
}
```

