---
title: "savannahnotes"
output: html_document
---
```{r}
adult_csv <- read.csv("/Users/srascon/Downloads/6210/git/HW2_Group14/adult.csv", sep = ";")
adult <- data.frame(adult_csv)
adult <- adult[,-1]

# change character columns to factor
adult$workclass <- as.factor(adult$workclass)
adult$education <- as.factor(adult$education)
adult$marital.status <- as.factor(adult$marital.status)
adult$occupation <- as.factor(adult$occupation)
adult$relationship <- as.factor(adult$relationship)
adult$race <- as.factor(adult$race)
adult$sex <- as.factor(adult$sex)
adult$native.country <- as.factor(adult$native.country)
adult$NA. <- as.factor(adult$NA.)

```

Section 3.2
```{r}

stability <- function(data, response, B = 100, K = 5, epsilon = 1e-6, 
                           delta = 2, L = 25, model_type = NULL) {
  
  result_matrix <- matrix(0, nrow = B, ncol = length(setdiff(names(data), response)),
                          dimnames = list(NULL, setdiff(names(data), response)))
  
  resampling <- vector("list", B)
  predictors <- colnames(result_matrix)
  p_length <- length(predictors)
  
  for (b in 1:B) {
    # Bootstrap
    index_b <- sample(1:nrow(data), size = nrow(data), replace = TRUE)
    data_b <- data[index_b, , drop = FALSE]
    
    # Fit model
    models_b <- build_paths(data_b, response,
                            K = K, epsilon = epsilon,
                            delta = delta, L = L,
                            model_type = model_type)
    
    # Feature inclusion
    counts <- rep(0, p)
    names(counts) <- predictors
    if (length(models_b) > 0) {
      for (m in models_b) counts[m$variables] <- counts[m$variables] + 1
    }
    
    # Proportions for Bootstrap sample
    z_j_b <- counts / (ifelse(length(models_b) > 0, length(models_b), 1)) # calculates ( z_j^{(b)} )
    result_matrix[b, ] <- z_j_b
    
    # Store proportions
    resampling [[b]] <- z_j_b
  }
  
  # Calculate stability
  pi <- colMeans(result_matrix)
  path_stability <- data.frame(variable = predictors, pi = pi)
  path_stability <- path_stability[order(-path_stability$pi), ]
  
  return(list(path_stability = path_stability, resampling = resampling))
}
```

Savannah's edits to build paths:
```{r}
# Edit build paths
X = adult[,1:14]
response = adult[,15]

cancer$Diagnosis <- as.factor(cancer$Diagnosis)

path_forest <- build_paths(X = cancer, response = "Diagnosis")

build_paths <- function(X, response, K = 5, epsilon = 10, delta = 200, L = 25, model_type = NULL){

  # --- Auto-detect model type ---
  detect_model_type <- function(response) {
    y <- X[,response]
    if (is.factor(y) || length(unique(y)) == 2) return("logistic")
    if (is.numeric(y)) return("linear")
    stop("Cannot detect model type automatically.")
  }

  if (is.null(model_type)) {
    model_type <- detect_model_type(response)
    cat("Detected model type:", model_type, "\n")
  }

  predictors <- colnames(X)
  response_name <- "response"

  # --- Model fitting helper ---
  fit_model <- function(vars) {
    formula_str <- paste(response, "~",
                         ifelse(length(vars) == 0, "1", paste(vars, collapse = "+")))
    if (model_type == "linear") {
      return(lm(as.formula(formula_str), data = X))
    } else {
      return(glm(as.formula(formula_str), data = X, family = binomial))
    }
  }
  
  # --- Start with null model ---
  null_fit <- fit_model(character())
  null_aic <- AIC(null_fit)
  null_vars <- c()
  
  # all_models is a list that contains lists for each set of models. The first list set is an entry for the null model which only contains the intercept.
  all_models <- list(list(variables = names(null_fit$coefficients), fit = null_fit, AIC = null_aic))
  
  start_models <- list()
  start_aic <- list()
  
  k <- 1
  frontiers <- list()
  aic_by_model <- list()
    
    for (a in 1:K) {
      
      if(k == 1){
        
        start_fit <- list()
        
        # make 1 predictor models
        for(i in 1:length(predictors)){
        
        suppressWarnings({
          start_fit[[i]] <- try(fit_model(predictors[i]), silent = TRUE)
        })
        if (inherits(start_fit[[i]], "try-error")) next
        
        # calculate AIC for 1 predictor models
        start_aic[i] <- AIC(start_fit[[i]])
        
        }
        
        # save info for 1 predictor models, add to total model list, move to k = 2
        start_models <- list(variables = predictors, fit = start_fit, AIC = start_aic)
       
        frontiers[[k]] <- start_models$variables
        aic_by_model[[k]] <- start_aic
        
         k <- k+1
        
      } else if(k == 2){
        
      # takes the variables from the 1 variables models
      current_vars <- start_models$variables
  
      vars_diff <- list()
      child_combos <- list()
      
      # determine sets of variables that make up the child combinations for this dimension
      for(b in 1:length(current_vars)){
      
      # this identifies the new variables that need to be added one by one to each model
      vars_diff[[b]] <- setdiff(predictors, current_vars[b])
      
      # for each parent model, make a list of new combinations that add one more variable
      child_combos[[b]] <- lapply(vars_diff[[b]], function(x) append(x, current_vars[b]))
      }
      
      # make a list to contain child models
      child_fit <- list()
      
      # make a list to contain child AIC
      child_fit_aic <- list()
      
      # models retained after comparison to parent
      child_retain <- list()
      
      for(b in 1:length(child_combos)){
        
        # fit child models for each parent model
        child_fit[[b]] <- lapply(child_combos[[b]], fit_model)
        
        # calculate AIC for each child model
        child_fit_aic[[b]] <- lapply(child_fit[[b]], AIC)
        
      }
      
        # make a list of each minimum aic for each set of models to use for filter
        child_min <- list()
        for(b in 1:length(child_fit_aic[[b]])){
          
        child_min[[b]] <- min(as.numeric(child_fit_aic[[b]]))
       
         }
        
        # compare AIC between child models and parent models
      extract_child_aic <- lapply(child_fit_aic, function(x) rep(NA, length(x)))

      for(b in seq_along(child_fit_aic)){
      for(c in seq_along(child_fit_aic[[b]])){
    
        
    aic_value  <- as.numeric(child_fit_aic[[b]][[c]])     # FIX
    min_value  <- as.numeric(child_min[[b]])
    start_val  <- as.numeric(start_aic[b])
    
    if(aic_value <= (min_value + delta) &&
       aic_value <= (start_val - epsilon)) {
      
      extract_child_aic[[b]][c] <- aic_value
         }
        }
      }
      
      extract_fit <- vector("list", length(child_fit_aic))
      extract_combos <- vector("list", length(child_fit_aic))

      for(b in seq_along(child_fit_aic)) {
  
      # Find which AICs passed your threshold
      keep_idx <- which(!is.na(extract_child_aic[[b]]))
  
      # Extract the models at the same positions
      extract_fit[[b]] <- child_fit[[b]][keep_idx]
      # Keep combos at the same positions
      extract_combos[[b]] <- child_combos[[b]][keep_idx]
      
      }
      
      extract_aic <- vector("list", length(child_fit_aic))
      extract_aic <- lapply(extract_child_aic, function(x) x[!is.na(x)])
      
      frontiers[[k]] <- extract_combos
      aic_by_model[[k]] <- extract_aic
      
      } else { #for dimensions greater than 2 
        
        # takes the variables from the extracted 2 variables models
      current_combos <- extract_combos
  
      vars_diff <- vector("list", length(current_combos))
      child_combos <- vector("list", length(current_combos))
      
      # determine sets of variables that make up the child combinations for this     dimension

      for(b in seq_along(current_combos)){
      
      child_combos[[b]] <- vector("list", length(current_combos[[b]]))
      vars_diff[[b]] <- vector("list", length(current_combos[[b]]))
  
      for(c in seq_along(current_combos[[b]])){
    
        parent_vars <- current_combos[[b]][[c]]   
        
        vars_diff[[b]][[c]] <- setdiff(predictors, parent_vars)
    
        # for each parent model, make a list of new combinations that add one more variable
        child_combos[[b]][[c]] <- lapply(vars_diff[[b]][[c]], 
                                         function(x) append( parent_vars, x))
           }
          }
      
        # make a list to contain child models
        child_fit <- vector("list", length(child_combos))
      
        # make a list to contain child AIC
        child_fit_aic <- vector("list", length(child_combos))
      
        # models retained after comparison to parent
        child_retain <- list()
      
      for(b in seq_along(child_combos)){
        
      child_fit[[b]] <- vector("list", length(child_combos[[b]]))
      child_fit_aic[[b]] <- vector("list", length(child_combos[[b]]))
      
        for(c in seq_along(child_combos[[b]])){
        
        # fit child models for each parent model
        child_fit[[b]][[c]] <- lapply(child_combos[[b]][[c]], fit_model)
        
        # calculate AIC for each child model
        child_fit_aic[[b]][[c]] <- lapply(child_fit[[b]][[c]], AIC)
        
        }
      }
        # find minimum AIC for each group
        child_min <- vector("list", length(child_fit_aic))
        for (b in seq_along(child_fit_aic)) {
        child_min[[b]] <- sapply(child_fit_aic[[b]], function(aic_list)
      min(as.numeric(aic_list))
    )
  }
  
        
        extract_child_aic <- child_fit_aic
  for (b in seq_along(child_fit_aic)) {
    for (c in seq_along(child_fit_aic[[b]])) {

      for (j in seq_along(child_fit_aic[[b]][[c]])) {
        aic_value <- as.numeric(child_fit_aic[[b]][[c]][[j]])
        min_value <- child_min[[b]][c]
        parent_aic <- extract_aic[[b]][c]

        if (aic_value <= (min_value + delta) &&
            aic_value <= (parent_aic - epsilon)) {

          extract_child_aic[[b]][[c]][[j]] <- aic_value
        } else {
          extract_child_aic[[b]][[c]][[j]] <- NA
        }
      }
    }
  }
        
     extract_fit <- vector("list", length(child_fit))
     extract_combos <- vector("list", length(child_fit))
     extract_aic <- vector("list", length(child_fit))
        
        for (b in seq_along(child_fit)) {
    extract_fit[[b]] <- vector("list", length(child_fit[[b]]))
    extract_combos[[b]] <- vector("list", length(child_fit[[b]]))
    extract_aic[[b]] <- vector("list", length(child_fit[[b]]))

    for (c in seq_along(child_fit[[b]])) {
      keep_idx <- which(!is.na(unlist(extract_child_aic[[b]][[c]])))

      extract_fit[[b]][[c]] <- child_fit[[b]][[c]][keep_idx]
      extract_combos[[b]][[c]] <- child_combos[[b]][[c]][keep_idx]
      extract_aic[[b]][[c]] <- unlist(extract_child_aic[[b]][[c]])[keep_idx]
    }
  }
    
     frontiers[[k]] <- extract_combos
     aic_by_model[[k]] <- extract_aic
     
  k <- k + 1
      }     
    }
  
  meta <- list("Dimensions" = K, "Epsilon" = epsilon, "Delta" = delta, "Limit_For_Retention" = L, "Model Type" = model_type)
  
  return(list(
  path_forest = list(
    frontiers = frontiers,
    aic_by_model = aic_by_model,
    meta = meta)
))
  
}
           
        
```
        
####### Working Build Paths Code: ###############
```{r}
X <- adult[,1:14]
response <- adult[,15]
adult$NA. <- as.factor(adult$NA.)
cancer <- as.data.frame(cancer)
str(cancer)

path_forest <- build_paths(X = cancer, response = "Diagnosis")
build_paths <- function(X, response, K = 5, epsilon = .001, delta = 2, L = 25, model_type = NULL) {
  
  # --- Auto-detect model type ---
  detect_model_type <- function(data, response_name) {
  y <- data[[response_name]]

  if (is.factor(y) || length(unique(y)) == 2) return("logistic")
  if (is.numeric(y)) return("linear")
  stop("Cannot detect model type automatically.")
}

  if (is.null(model_type)) {
    model_type <- detect_model_type(X, response)
    cat("Detected model type:", model_type, "\n")
  }
  
  predictors <- colnames(X)
  predictors <- setdiff(predictors, response)  # exclude response

  # --- Model fitting helper ---
  fit_model <- function(vars) {
    formula_str <- paste(response, "~", ifelse(length(vars) == 0, "1", paste(vars, collapse = "+")))
    if (model_type == "linear") {
      return(lm(as.formula(formula_str), data = X))
    } else {
      return(glm(as.formula(formula_str), data = X, family = binomial))
    }
  }

  # --- Initialize storage ---
  frontiers <- list()
  aic_by_model <- list()

  # --- Level 1: single-variable models ---
  start_fit <- vector("list", length(predictors))
  start_aic <- rep(NA, length(predictors))


  for (i in seq_along(predictors)) {
    suppressWarnings({
      start_fit[[i]] <- try(fit_model(predictors[i]), silent = TRUE)
    })
    if (!inherits(start_fit[[i]], "try-error")) {
      start_aic[i] <- AIC(start_fit[[i]])
    } else {
      start_fit[[i]] <- NA
      start_aic[i] <- NA
    }
  }

  # Save first frontier
  frontiers[[1]] <- lapply(seq_along(predictors), function(i) list(vars = predictors[i], fit = start_fit[[i]], aic = start_aic[i]))
  aic_by_model[[1]] <- start_aic

  # --- Loop over higher dimensions ---
  current_frontier <- frontiers[[1]]

  for (k in 2:K) {

    all_children <- list()
    all_children_aic <- numeric(0)

    for (parent in current_frontier) {
      parent_vars <- parent$vars
      parent_aic  <- parent$aic

      remaining <- setdiff(predictors, parent_vars)
      child_list <- list()
      child_aics <- numeric(0)

      for (v in remaining) {
        new_vars <- c(parent_vars, v)
        fit <- try(fit_model(new_vars), silent = TRUE)
        if (!inherits(fit, "try-error")) {
          aic <- AIC(fit)
          child_list <- append(child_list, list(list(vars = new_vars, fit = fit, aic = aic)))
          child_aics <- c(child_aics, aic)
        }
      }

      # Option A filtering
      if (length(child_aics) > 0) {
        best_child_aic <- min(child_aics, na.rm = TRUE)
        keep_idx <- which((child_aics - best_child_aic <= delta) & (parent_aic - child_aics > epsilon))
        if (length(keep_idx) > 0) {
          all_children <- append(all_children, child_list[keep_idx])
          all_children_aic <- c(all_children_aic, child_aics[keep_idx])
        }
      }
    }

    # Deduplicate by variable set
    if (length(all_children) > 0) {
      keys <- sapply(all_children, function(m) paste(sort(m$vars), collapse = "_"))
      all_children <- all_children[!duplicated(keys)]
      all_children_aic <- sapply(all_children, function(m) m$aic)

      # Keep top L by AIC if too many
      if (length(all_children) > L) {
        idx <- order(all_children_aic)[1:L]
        all_children <- all_children[idx]
      }
    }

    # Save this level
    frontiers[[k]] <- all_children
    aic_by_model[[k]] <- sapply(all_children, function(m) m$aic)
    current_frontier <- all_children
  }

  meta <- list(Dimensions = K, Epsilon = epsilon, Delta = delta, Limit_For_Retention = L, Model_Type = model_type)

  return(list(
    path_forest = list(
      frontiers = frontiers,
      aic_by_model = aic_by_model,
      meta = meta
    )
  ))
}


```
     
```{r}
build_path_debug <- build_paths_debug(X = cancer, response = "Diagnosis")

build_paths_debug <- function(X, response, K = 5, epsilon = 0.001, delta = 2, L = 25,
                              model_type = NULL, verbose = TRUE) {

  # Defensive checks
  if (!is.data.frame(X)) stop("X must be a data.frame")
  if (!is.character(response) || length(response) != 1) stop("response must be the column name (string) in X")

  if (!(response %in% colnames(X))) stop("response not found in X")

  # --- Auto-detect model type ---
  detect_model_type <- function(y) {
    if (is.factor(y) || length(unique(y)) == 2) return("logistic")
    if (is.numeric(y)) return("linear")
    stop("Cannot detect model type automatically.")
  }

  yvec <- X[[response]]
  if (any(is.na(yvec))) {
    warning("Response contains NA values. These rows will be removed for modeling.")
  }

  if (is.null(model_type)) {
    model_type <- detect_model_type(yvec)
  }
  if (verbose) cat("Detected model type:", model_type, "\n")

  # Preprocess predictors: remove response, drop constant columns, coerce characters to factors
  preds <- setdiff(colnames(X), response)
  if (length(preds) == 0) stop("No predictor columns found after removing response")

  # convert character predictors to factors (glm/lm accept factors)
  for (p in preds) {
    if (is.character(X[[p]])) {
      X[[p]] <- as.factor(X[[p]])
      if (verbose) cat("Converted predictor", p, "from character -> factor\n")
    }
  }

  # drop predictors with zero variance
  zero_var <- sapply(preds, function(p) {
    length(unique(na.omit(X[[p]]))) <= 1
  })
  if (any(zero_var)) {
    drop <- preds[zero_var]
    preds <- setdiff(preds, drop)
    if (verbose) cat("Dropped zero-variance predictors:", paste(drop, collapse = ", "), "\n")
  }
  if (length(preds) == 0) stop("No usable predictors after dropping zero-variance columns")

  # helper to safely fit models and capture errors
  safe_fit <- function(vars) {
    fstr <- paste(response, "~", ifelse(length(vars) == 0, "1", paste(vars, collapse = "+")))
    res <- list(success = FALSE, fit = NULL, aic = NA_real_, error = NULL)
    try_expr <- tryCatch({
      if (model_type == "linear") {
        fit <- lm(as.formula(fstr), data = X, na.action = na.exclude)
      } else {
        fit <- glm(as.formula(fstr), data = X, family = binomial, na.action = na.exclude)
      }
      a <- tryCatch(AIC(fit), error = function(e) NA_real_)
      res$success <- TRUE
      res$fit <- fit
      res$aic <- a
      res
    }, error = function(e) {
      res$error <- conditionMessage(e)
      res
    }, warning = function(w) {
      # capture warnings but still keep model if successful
      invokeRestart("muffleWarning") # suppress here
    })
    try_expr
  }

  # Storage
  frontiers <- list()
  aic_by_model <- list()
  diagnostics <- list(levels = vector("list", K))

  # Level 1: single-variable models
  start_fit <- vector("list", length(preds))
  start_aic <- rep(NA_real_, length(preds))
  fit_ok_idx <- logical(length(preds))
  fit_errors <- vector("list", length(preds))

  for (i in seq_along(preds)) {
    res <- safe_fit(preds[i])
    if (res$success) {
      start_fit[[i]] <- res$fit
      start_aic[i] <- res$aic
      fit_ok_idx[i] <- TRUE
    } else {
      start_fit[[i]] <- NA
      start_aic[i] <- NA
      fit_errors[[i]] <- res$error
    }
  }

  # diagnostics for level 1
  diagnostics$levels[[1]] <- list(predictors = preds, fit_ok = fit_ok_idx, errors = fit_errors)
  if (verbose) {
    cat("Level 1: tried", length(preds), "single-var models;", sum(fit_ok_idx), "succeeded.\n")
    if (sum(!fit_ok_idx) > 0) {
      cat("  Failures (example):\n")
      idx_fail <- which(!fit_ok_idx)
      for (j in head(idx_fail, 5)) cat("   -", preds[j], "=>", fit_errors[[j]], "\n")
    }
  }

  frontiers[[1]] <- lapply(seq_along(preds), function(i)
    list(vars = preds[i], fit = if (fit_ok_idx[i]) start_fit[[i]] else NA, aic = start_aic[i])
  )
  aic_by_model[[1]] <- start_aic

  current_frontier <- frontiers[[1]]

  # MAIN loop levels 2..K
  for (k in 2:K) {
    if (verbose) cat("Starting level", k, "with", length(current_frontier), "parents\n")
    children_all <- list()
    children_aic_all <- numeric(0)
    level_diag <- list()

    for (pi in seq_along(current_frontier)) {
      parent <- current_frontier[[pi]]
      parent_vars <- parent$vars
      parent_aic <- parent$aic

      remaining <- setdiff(preds, parent_vars)
      if (length(remaining) == 0) next

      child_list <- list()
      child_aics <- numeric(0)
      child_errors <- list()

      for (v in remaining) {
        new_vars <- c(parent_vars, v)
        res <- safe_fit(new_vars)
        if (res$success) {
          child_list <- append(child_list, list(list(vars = new_vars, fit = res$fit, aic = res$aic)))
          child_aics <- c(child_aics, res$aic)
          child_errors <- c(child_errors, NA)
        } else {
          child_list <- append(child_list, list(NULL))
          child_aics <- c(child_aics, NA_real_)
          child_errors <- c(child_errors, res$error)
        }
      }

      # store diagnostics for this parent
      level_diag[[pi]] <- list(parent = parent_vars, remaining = remaining,
                               child_aics = child_aics, child_errors = child_errors)

      # Option A filtering: keep children that are within delta of parent's best child AND improve on parent by > epsilon
      if (all(is.na(child_aics))) {
        next
      }
      best_child_aic <- min(child_aics, na.rm = TRUE)
      keep_idx <- which(!is.na(child_aics) &
                        (child_aics - best_child_aic <= delta) &
                        ((parent_aic - child_aics) > epsilon))

      if (length(keep_idx) > 0) {
        # only append actual successful child_list entries
        to_append <- child_list[keep_idx]
        # some entries may be NULL (failed fits) - filter them
        valid_mask <- sapply(to_append, function(x) !is.null(x))
        if (any(valid_mask)) {
          to_append <- to_append[valid_mask]
          children_all <- append(children_all, to_append)
          children_aic_all <- c(children_aic_all, sapply(to_append, function(x) x$aic))
        }
      }
    } # end parents

    # diagnostics
    diagnostics$levels[[k]] <- level_diag

    # dedupe children
    if (length(children_all) == 0) {
      if (verbose) cat("Level", k, ": no children survived filtering -> stopping.\n")
      frontiers[[k]] <- list()
      aic_by_model[[k]] <- numeric(0)
      break
    }

    keys <- sapply(children_all, function(m) paste(sort(m$vars), collapse = "_"))
    keep_unique <- !duplicated(keys)
    children_all <- children_all[keep_unique]
    children_aic_all <- sapply(children_all, function(m) m$aic)

    # keep top L
    if (length(children_all) > L) {
      idx_keep <- order(children_aic_all)[1:L]
      children_all <- children_all[idx_keep]
      children_aic_all <- children_aic_all[idx_keep]
    }

    # save frontier k
    frontiers[[k]] <- children_all
    aic_by_model[[k]] <- children_aic_all
    current_frontier <- children_all

    if (verbose) cat("Level", k, "-> retained", length(children_all), "models\n")
  } # end levels

  return(list(path_forest = list(frontiers = frontiers, aic_by_model = aic_by_model, meta = list(K = K, epsilon = epsilon, delta = delta, L = L, model_type = model_type)), diagnostics = diagnostics))
}

```

   
        
 
