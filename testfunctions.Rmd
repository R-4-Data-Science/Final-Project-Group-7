---
title: "testfunctions"
output: html_document
---

```{r}
adult_csv <- read.csv("/Users/srascon/Downloads/6210/git/HW2_Group14/adult.csv", sep = ";")
adult <- data.frame(adult_csv)
adult <- adult[,-1]

# change character columns to factor
adult$workclass <- as.factor(adult$workclass)
adult$education <- as.factor(adult$education)
adult$marital.status <- as.factor(adult$marital.status)
adult$occupation <- as.factor(adult$occupation)
adult$relationship <- as.factor(adult$relationship)
adult$race <- as.factor(adult$race)
adult$sex <- as.factor(adult$sex)
adult$native.country <- as.factor(adult$native.country)
adult$NA. <- as.factor(adult$NA.)

```



```{r}
cancer <- breastcancer
View(cancer)
cancer <- cancer[,-1]
names(cancer) <- c("Diagnosis", "radius1", "texture1", "perimeter1", "area1", "smoothness1", "compactness", "concavity1", "concave_point", "symmetry", "fractal_dimension", "radius2", "texture2", "perimeter2", "area2", "smoothness2", "compactness2", "concavity2", "concave_points2", "symmetry2", "fractal_dimension2", "radius3", "texture3", "perimeter3", "area3", "smoothness3", "compactness3", "concavity3", "concave_points3", "symmetry3", "fractal_dimension3")

path_forest <- build_paths(X = cancer, response = "Diagnosis")
build_paths <- function(X, response, K = 5, epsilon = 0.0000001, delta = 2, L = 25, model_type = NULL) {

  # --- Auto-detect model type ---
  detect_model_type <- function(y) {
    if (is.factor(y) || length(unique(y)) == 2) return("logistic")
    if (is.numeric(y)) return("linear")
    stop("Cannot detect model type automatically.")
  }

  # response is passed as a column name
  y <- X[[response]]

  if (is.null(model_type)) {
    model_type <- detect_model_type(y)
    cat("Detected model type:", model_type, "\n")
  }

  predictors <- setdiff(colnames(X), response)

  # --- Model fitting helper ---
  fit_model <- function(vars) {
    formula_str <- paste(response, "~",
                         ifelse(length(vars) == 0, "1", paste(vars, collapse = "+")))

    if (model_type == "linear") {
      return(lm(as.formula(formula_str), data = X))
    } else {
      return(glm(as.formula(formula_str), data = X, family = binomial))
    }
  }

  # --- Initialize storage ---
  frontiers <- list()
  aic_by_model <- list()

  # ===============================
  # LEVEL 1: Single-variable models
  # ===============================

  start_fit <- vector("list", length(predictors))
  start_aic <- rep(NA, length(predictors))

  for (i in seq_along(predictors)) {

    suppressWarnings({
      fit_try <- try(fit_model(predictors[i]), silent = TRUE)
    })

    if (!inherits(fit_try, "try-error")) {
      start_fit[[i]] <- fit_try
      start_aic[i] <- AIC(fit_try)
    } else {
      start_fit[[i]] <- NA      # â† FIXED: do NOT use NULL
      start_aic[i] <- NA
    }
  }

  frontiers[[1]] <- lapply(seq_along(predictors), function(i) {
    list(vars = predictors[i], fit = start_fit[[i]], aic = start_aic[i])
  })

  aic_by_model[[1]] <- start_aic

  current_frontier <- frontiers[[1]]

  # ===============================
  # LEVELS 2 through K
  # ===============================

  for (k in 2:K) {

    all_children <- list()
    all_children_aic <- numeric(0)

    for (parent in current_frontier) {

      parent_vars <- parent$vars
      parent_aic  <- parent$aic

      remaining <- setdiff(predictors, parent_vars)

      child_list <- list()
      child_aics <- numeric(0)

      # --- Build children by adding each remaining variable ---
      for (v in remaining) {

        new_vars <- c(parent_vars, v)

        fit_try <- try(fit_model(new_vars), silent = TRUE)

        if (!inherits(fit_try, "try-error")) {

          aic <- AIC(fit_try)

          child_list <- append(child_list, list(
            list(vars = new_vars, fit = fit_try, aic = aic)
          ))

          child_aics <- c(child_aics, aic)
        }
      }

      if (length(child_aics) > 0) {

        best_child_aic <- min(child_aics, na.rm = TRUE)

        # Option A filtering
        keep_idx <- which(
          (child_aics - best_child_aic <= delta) &   # Within delta
          (parent_aic - child_aics > epsilon)        # Improves by epsilon
        )

        if (length(keep_idx) > 0) {
          all_children <- append(all_children, child_list[keep_idx])
          all_children_aic <- c(all_children_aic, child_aics[keep_idx])
        }
      }
    }

    # --- Deduplicate by sorted variable-set signature ---
    if (length(all_children) > 0) {

      keys <- sapply(all_children, function(m)
        paste(sort(m$vars), collapse = "_")
      )

      keep <- !duplicated(keys)
      all_children <- all_children[keep]
      all_children_aic <- sapply(all_children, function(m) m$aic)

      # --- Keep best L ---
      if (length(all_children) > L) {
        idx <- order(all_children_aic)[1:L]
        all_children <- all_children[idx]
      }
    }

    # Save frontier k
    frontiers[[k]] <- all_children
    aic_by_model[[k]] <- sapply(all_children, function(m) m$aic)

    current_frontier <- all_children
  }

  meta <- list(
    Dimensions = K,
    Epsilon = epsilon,
    Delta = delta,
    Limit_For_Retention = L,
    Model_Type = model_type
  )

  return(list(
    path_forest = list(
      frontiers = frontiers,
      aic_by_model = aic_by_model,
      meta = meta
    )
  ))
}


```


